
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from django.shortcuts import get_object_or_404

from games.models import Episode, Category, Clue, Game, GameParticipant
from users.models import Player
from .serializers import (
        EpisodeSerializer, EpisodeListSerializer, CategorySerializer,
        ClueSerializer, GameSerializer, GameCreateSerializer,
        PlayerSerializer, GameParticipantSerializer
)


class EpisodeViewSet(viewsets.ReadOnlyModelViewSet):
    """
    ViewSet for viewing episodes.
    Read-only because episodes shouldn't be created via API.

    Endpoints:
    - GET /api/episodes/ - List all episodes
    - Get /api/episodes/{id}/ - Get specific episode
    - Get /api/episodes/search/ - Search by season/episode number
    """
    queryset = Episode.objects.all().prefetch_related('category_set__clue_set')
    # prefetch_related loads categories and clues in fewer queries (optimization)

    permission_classes = [AllowAny] # Anyone can view episodes

    def get_serializer_class(self):
        """
        Use different serializers for list vs detail view.
        List: lightweight (no categories)
        Detail: full data (with categories and clues)
        """
        if self.action == 'list':
            return EpisodeListSerializer
        return EpisodeSerializer

    @action(detail=False, methods=['get'])
    def search(self, request):
        """
        Custom endpoint: /api/episodes/search/?season=1&episode=5

        Search for episodes by season and/or episode number.
        """
        season = request.query_params.get('season')
        episode = request.query_params.get('episode')

        queryset = self.get_queryset()

        if season:
            queryset = queryset.filter(season_number=season)
        if episode:
            queryset = queryset.filter(episode_number=episode)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['get'])
    def random(self, request):
        """
        Custom endpoint: /api/episodes/random/

        Get a random episode for quick play.
        """
        episode = Episode.objects.order_by('?').first()
        # order_by('?') returns random order

        if not episode:
            return Response(
                {'error': 'No episodes available'},
                status=status.HTTP_404_NOT_FOUND
            )

        serializer = self.get_serializer(episode)
        return Response(serializer.data)


class PlayerViewSet(viewsets.ModelViewSet):
    """
    ViewSet for managing players.

    Endpoints:
    - GET /api/players/ - List all players
    - POST /api/plaers/ - Create new player
    - GET /api/players/{id}/ - Get specific player
    - PATCH /api/players/{id}/ - Update player
    - DELTE /api/players/{id}/ - Delte player
    """
    queryset = Player.objects.all()
    serializer_class = PlayerSerializer
    permission_classes = [AllowAny]

    @action(detail=False, methods=['post'])
    def create_guest(self, request):
        """
        Custom endpoint: /api/players/create_guest/

        Create a guest player (no authentication required).
        """
        display_name = request.data.get('display_name')

        if not display_name:
            return Response(
                    {'error': 'display_name is required'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        player = Player.objects.create(
                display_name=display_name,
                # guest_session will be auto-generated by model default
        )

        serializer = self.get_serializer(player)
        return Response(serializer.data, status=status.HTTP_201_CREATED)



class GameViewSet(viewsets.ModelViewSet):
    """
    ViewSet for managing games.

    Endpoints:
    - GET /api/games/ - List all games
    - POST /api/games/ - Create new game
    - GET /api/games/{game_id}/ - Get specific game
    - PATCH /api/games/{game_id}/ - Update game
    - DELETE /api/games/{game_id}/ - Delete game
    """
    queryset = Game.objects.all().select_related('episode', 'host').prefetch_related('gameparticipant_set__player')
    serializer_class = GameSerializer
    permission_classes = [AllowAny]
    lookup_field = 'game_id' # Use game_id instead of default 'pk'

    def get_serializer_class(self):
        """Use simplified serializer for creation."""
        if self.action == 'create':
            return GameCreateSerializer
        return GameSerializer

    def create(self, request, *args, **kwargs):
        """
        Override create to return full game data with game_id.
        Input: GameCreateSerializer (minimal fields)
        Output: GameSerializer (all fields including game_id)
        """
        # Validate input with GameCreateSerializer
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Save the game
        game = serializer.save()

        # Return full game data using GameSerializer
        output_serializer = GameSerializer(game)
        return Response(output_serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['post'])
    def join(self, request, game_id=None):
        """
        Custom endpoint: /api/games/{game_id}/join/

        Join a game as a player.

        Body: {
            "player_id": 123,
            "display_name": "Alex" (optional, for guest players)
        }
        """
        game = self.get_object()

        # Check if game is joinable
        if game.status not in ['waiting', 'active']:
            return Response(
                    {'error': 'Game is not accepting new players'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        # Check if game is full
        current_players = GameParticipant.objects.filter(game=game).count()
        if current_players >= 3:
            return Response(
                    {'error': 'Game is full (max 3 players)'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        # Get or create player
        player_id = request.data.get('player_id')
        display_name = request.data.get('display_name')

        if player_id:
            player = get_object_or_404(Player, id=player_id)
        elif display_name:
            # Create guest player
            player = Player.objects.create(display_name=display_name)
        else:
            return Response(
                {'error': 'Either player_id or display_name required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Check if player already in game
        if GameParticipant.objects.filter(game=game, player=player).exists():
            return Response(
                    {'error': 'Player already in this game'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        # Add player to game
        participant = GameParticipant.objects.create(
                game=game,
                player=player,
                player_number=current_players + 1
        )

        serializer = GameParticipantSerializer(participant)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['get'])
    def state(self, request, game_id=None):
        """
        Custom endpoint: /api/games/{game_id}/state/

        Get current game state (will be enhanced with Redis in next steps).
        """
        game = self.get_object()

        # For now, just return database state
        # Later, we'll merge with Redis state
        serializer  = self.get_serializer(game)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def start(self, request, game_id=None):
        """
        Custom endpoint: /api/games/{game_id}/start/

        Start the game.
        """
        game = self.get_object()

        if game.status != 'waiting':
            return Response(
                    {'error': 'Game already started'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        # Check minimum players
        player_count = GameParticipant.objects.filter(game=game).count()
        if player_count < 1:
            return Response(
                    {'error': 'Need at least 1 player to start'},
                    status=status.HTTP_400_BAD_REQUEST
            )

        # Update game status
        from django.utils import timezone
        game.status = 'active'
        game.startd_at = timezone.now()
        game.save()

        serializer = self.get_serializer(game)
        return Response(serializer.data)















































